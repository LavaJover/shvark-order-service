// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: order.proto

package orderpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	OrderService_CreateOrder_FullMethodName         = "/order.OrderService/CreateOrder"
	OrderService_ApproveOrder_FullMethodName        = "/order.OrderService/ApproveOrder"
	OrderService_CancelOrder_FullMethodName         = "/order.OrderService/CancelOrder"
	OrderService_OpenOrderDispute_FullMethodName    = "/order.OrderService/OpenOrderDispute"
	OrderService_ResolveOrderDispute_FullMethodName = "/order.OrderService/ResolveOrderDispute"
	OrderService_GetOrderByID_FullMethodName        = "/order.OrderService/GetOrderByID"
	OrderService_GetOrdersByTraderID_FullMethodName = "/order.OrderService/GetOrdersByTraderID"
	OrderService_CreateOrderDispute_FullMethodName  = "/order.OrderService/CreateOrderDispute"
	OrderService_AcceptOrderDispute_FullMethodName  = "/order.OrderService/AcceptOrderDispute"
	OrderService_RejectOrderDispute_FullMethodName  = "/order.OrderService/RejectOrderDispute"
	OrderService_GetOrderDisputeInfo_FullMethodName = "/order.OrderService/GetOrderDisputeInfo"
	OrderService_FreezeOrderDispute_FullMethodName  = "/order.OrderService/FreezeOrderDispute"
)

// OrderServiceClient is the client API for OrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrderServiceClient interface {
	CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error)
	ApproveOrder(ctx context.Context, in *ApproveOrderRequest, opts ...grpc.CallOption) (*ApproveOrderResponse, error)
	CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error)
	OpenOrderDispute(ctx context.Context, in *OpenOrderDisputeRequest, opts ...grpc.CallOption) (*OpenOrderDisputeResponse, error)
	ResolveOrderDispute(ctx context.Context, in *ResolveOrderDisputeRequest, opts ...grpc.CallOption) (*ResolveOrderDisputeResponse, error)
	GetOrderByID(ctx context.Context, in *GetOrderByIDRequest, opts ...grpc.CallOption) (*GetOrderByIDResponse, error)
	GetOrdersByTraderID(ctx context.Context, in *GetOrdersByTraderIDRequest, opts ...grpc.CallOption) (*GetOrdersByTraderIDResponse, error)
	CreateOrderDispute(ctx context.Context, in *CreateOrderDisputeRequest, opts ...grpc.CallOption) (*CreateOrderDisputeResponse, error)
	AcceptOrderDispute(ctx context.Context, in *AcceptOrderDisputeRequest, opts ...grpc.CallOption) (*AcceptOrderDisputeResponse, error)
	RejectOrderDispute(ctx context.Context, in *RejectOrderDisputeRequest, opts ...grpc.CallOption) (*RejectOrderDisputeResponse, error)
	GetOrderDisputeInfo(ctx context.Context, in *GetOrderDisputeInfoRequest, opts ...grpc.CallOption) (*GetOrderDisputeInfoResponse, error)
	FreezeOrderDispute(ctx context.Context, in *FreezeOrderDisputeRequest, opts ...grpc.CallOption) (*FreezeOrderDisputeResponse, error)
}

type orderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOrderServiceClient(cc grpc.ClientConnInterface) OrderServiceClient {
	return &orderServiceClient{cc}
}

func (c *orderServiceClient) CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateOrderResponse)
	err := c.cc.Invoke(ctx, OrderService_CreateOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) ApproveOrder(ctx context.Context, in *ApproveOrderRequest, opts ...grpc.CallOption) (*ApproveOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApproveOrderResponse)
	err := c.cc.Invoke(ctx, OrderService_ApproveOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelOrderResponse)
	err := c.cc.Invoke(ctx, OrderService_CancelOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) OpenOrderDispute(ctx context.Context, in *OpenOrderDisputeRequest, opts ...grpc.CallOption) (*OpenOrderDisputeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenOrderDisputeResponse)
	err := c.cc.Invoke(ctx, OrderService_OpenOrderDispute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) ResolveOrderDispute(ctx context.Context, in *ResolveOrderDisputeRequest, opts ...grpc.CallOption) (*ResolveOrderDisputeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveOrderDisputeResponse)
	err := c.cc.Invoke(ctx, OrderService_ResolveOrderDispute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) GetOrderByID(ctx context.Context, in *GetOrderByIDRequest, opts ...grpc.CallOption) (*GetOrderByIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOrderByIDResponse)
	err := c.cc.Invoke(ctx, OrderService_GetOrderByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) GetOrdersByTraderID(ctx context.Context, in *GetOrdersByTraderIDRequest, opts ...grpc.CallOption) (*GetOrdersByTraderIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOrdersByTraderIDResponse)
	err := c.cc.Invoke(ctx, OrderService_GetOrdersByTraderID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) CreateOrderDispute(ctx context.Context, in *CreateOrderDisputeRequest, opts ...grpc.CallOption) (*CreateOrderDisputeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateOrderDisputeResponse)
	err := c.cc.Invoke(ctx, OrderService_CreateOrderDispute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) AcceptOrderDispute(ctx context.Context, in *AcceptOrderDisputeRequest, opts ...grpc.CallOption) (*AcceptOrderDisputeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AcceptOrderDisputeResponse)
	err := c.cc.Invoke(ctx, OrderService_AcceptOrderDispute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) RejectOrderDispute(ctx context.Context, in *RejectOrderDisputeRequest, opts ...grpc.CallOption) (*RejectOrderDisputeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RejectOrderDisputeResponse)
	err := c.cc.Invoke(ctx, OrderService_RejectOrderDispute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) GetOrderDisputeInfo(ctx context.Context, in *GetOrderDisputeInfoRequest, opts ...grpc.CallOption) (*GetOrderDisputeInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOrderDisputeInfoResponse)
	err := c.cc.Invoke(ctx, OrderService_GetOrderDisputeInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) FreezeOrderDispute(ctx context.Context, in *FreezeOrderDisputeRequest, opts ...grpc.CallOption) (*FreezeOrderDisputeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FreezeOrderDisputeResponse)
	err := c.cc.Invoke(ctx, OrderService_FreezeOrderDispute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrderServiceServer is the server API for OrderService service.
// All implementations must embed UnimplementedOrderServiceServer
// for forward compatibility.
type OrderServiceServer interface {
	CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error)
	ApproveOrder(context.Context, *ApproveOrderRequest) (*ApproveOrderResponse, error)
	CancelOrder(context.Context, *CancelOrderRequest) (*CancelOrderResponse, error)
	OpenOrderDispute(context.Context, *OpenOrderDisputeRequest) (*OpenOrderDisputeResponse, error)
	ResolveOrderDispute(context.Context, *ResolveOrderDisputeRequest) (*ResolveOrderDisputeResponse, error)
	GetOrderByID(context.Context, *GetOrderByIDRequest) (*GetOrderByIDResponse, error)
	GetOrdersByTraderID(context.Context, *GetOrdersByTraderIDRequest) (*GetOrdersByTraderIDResponse, error)
	CreateOrderDispute(context.Context, *CreateOrderDisputeRequest) (*CreateOrderDisputeResponse, error)
	AcceptOrderDispute(context.Context, *AcceptOrderDisputeRequest) (*AcceptOrderDisputeResponse, error)
	RejectOrderDispute(context.Context, *RejectOrderDisputeRequest) (*RejectOrderDisputeResponse, error)
	GetOrderDisputeInfo(context.Context, *GetOrderDisputeInfoRequest) (*GetOrderDisputeInfoResponse, error)
	FreezeOrderDispute(context.Context, *FreezeOrderDisputeRequest) (*FreezeOrderDisputeResponse, error)
	mustEmbedUnimplementedOrderServiceServer()
}

// UnimplementedOrderServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOrderServiceServer struct{}

func (UnimplementedOrderServiceServer) CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrder not implemented")
}
func (UnimplementedOrderServiceServer) ApproveOrder(context.Context, *ApproveOrderRequest) (*ApproveOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveOrder not implemented")
}
func (UnimplementedOrderServiceServer) CancelOrder(context.Context, *CancelOrderRequest) (*CancelOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (UnimplementedOrderServiceServer) OpenOrderDispute(context.Context, *OpenOrderDisputeRequest) (*OpenOrderDisputeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenOrderDispute not implemented")
}
func (UnimplementedOrderServiceServer) ResolveOrderDispute(context.Context, *ResolveOrderDisputeRequest) (*ResolveOrderDisputeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveOrderDispute not implemented")
}
func (UnimplementedOrderServiceServer) GetOrderByID(context.Context, *GetOrderByIDRequest) (*GetOrderByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrderByID not implemented")
}
func (UnimplementedOrderServiceServer) GetOrdersByTraderID(context.Context, *GetOrdersByTraderIDRequest) (*GetOrdersByTraderIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrdersByTraderID not implemented")
}
func (UnimplementedOrderServiceServer) CreateOrderDispute(context.Context, *CreateOrderDisputeRequest) (*CreateOrderDisputeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrderDispute not implemented")
}
func (UnimplementedOrderServiceServer) AcceptOrderDispute(context.Context, *AcceptOrderDisputeRequest) (*AcceptOrderDisputeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptOrderDispute not implemented")
}
func (UnimplementedOrderServiceServer) RejectOrderDispute(context.Context, *RejectOrderDisputeRequest) (*RejectOrderDisputeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RejectOrderDispute not implemented")
}
func (UnimplementedOrderServiceServer) GetOrderDisputeInfo(context.Context, *GetOrderDisputeInfoRequest) (*GetOrderDisputeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrderDisputeInfo not implemented")
}
func (UnimplementedOrderServiceServer) FreezeOrderDispute(context.Context, *FreezeOrderDisputeRequest) (*FreezeOrderDisputeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FreezeOrderDispute not implemented")
}
func (UnimplementedOrderServiceServer) mustEmbedUnimplementedOrderServiceServer() {}
func (UnimplementedOrderServiceServer) testEmbeddedByValue()                      {}

// UnsafeOrderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrderServiceServer will
// result in compilation errors.
type UnsafeOrderServiceServer interface {
	mustEmbedUnimplementedOrderServiceServer()
}

func RegisterOrderServiceServer(s grpc.ServiceRegistrar, srv OrderServiceServer) {
	// If the following call pancis, it indicates UnimplementedOrderServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OrderService_ServiceDesc, srv)
}

func _OrderService_CreateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).CreateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_CreateOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).CreateOrder(ctx, req.(*CreateOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_ApproveOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).ApproveOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_ApproveOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).ApproveOrder(ctx, req.(*ApproveOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_CancelOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).CancelOrder(ctx, req.(*CancelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_OpenOrderDispute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenOrderDisputeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).OpenOrderDispute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_OpenOrderDispute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).OpenOrderDispute(ctx, req.(*OpenOrderDisputeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_ResolveOrderDispute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveOrderDisputeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).ResolveOrderDispute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_ResolveOrderDispute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).ResolveOrderDispute(ctx, req.(*ResolveOrderDisputeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_GetOrderByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrderByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).GetOrderByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_GetOrderByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).GetOrderByID(ctx, req.(*GetOrderByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_GetOrdersByTraderID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrdersByTraderIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).GetOrdersByTraderID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_GetOrdersByTraderID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).GetOrdersByTraderID(ctx, req.(*GetOrdersByTraderIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_CreateOrderDispute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrderDisputeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).CreateOrderDispute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_CreateOrderDispute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).CreateOrderDispute(ctx, req.(*CreateOrderDisputeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_AcceptOrderDispute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptOrderDisputeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).AcceptOrderDispute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_AcceptOrderDispute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).AcceptOrderDispute(ctx, req.(*AcceptOrderDisputeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_RejectOrderDispute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectOrderDisputeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).RejectOrderDispute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_RejectOrderDispute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).RejectOrderDispute(ctx, req.(*RejectOrderDisputeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_GetOrderDisputeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrderDisputeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).GetOrderDisputeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_GetOrderDisputeInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).GetOrderDisputeInfo(ctx, req.(*GetOrderDisputeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_FreezeOrderDispute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FreezeOrderDisputeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).FreezeOrderDispute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_FreezeOrderDispute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).FreezeOrderDispute(ctx, req.(*FreezeOrderDisputeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OrderService_ServiceDesc is the grpc.ServiceDesc for OrderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "order.OrderService",
	HandlerType: (*OrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrder",
			Handler:    _OrderService_CreateOrder_Handler,
		},
		{
			MethodName: "ApproveOrder",
			Handler:    _OrderService_ApproveOrder_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _OrderService_CancelOrder_Handler,
		},
		{
			MethodName: "OpenOrderDispute",
			Handler:    _OrderService_OpenOrderDispute_Handler,
		},
		{
			MethodName: "ResolveOrderDispute",
			Handler:    _OrderService_ResolveOrderDispute_Handler,
		},
		{
			MethodName: "GetOrderByID",
			Handler:    _OrderService_GetOrderByID_Handler,
		},
		{
			MethodName: "GetOrdersByTraderID",
			Handler:    _OrderService_GetOrdersByTraderID_Handler,
		},
		{
			MethodName: "CreateOrderDispute",
			Handler:    _OrderService_CreateOrderDispute_Handler,
		},
		{
			MethodName: "AcceptOrderDispute",
			Handler:    _OrderService_AcceptOrderDispute_Handler,
		},
		{
			MethodName: "RejectOrderDispute",
			Handler:    _OrderService_RejectOrderDispute_Handler,
		},
		{
			MethodName: "GetOrderDisputeInfo",
			Handler:    _OrderService_GetOrderDisputeInfo_Handler,
		},
		{
			MethodName: "FreezeOrderDispute",
			Handler:    _OrderService_FreezeOrderDispute_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "order.proto",
}

const (
	TrafficService_AddTraffic_FullMethodName             = "/order.TrafficService/AddTraffic"
	TrafficService_EditTraffic_FullMethodName            = "/order.TrafficService/EditTraffic"
	TrafficService_DeleteTraffic_FullMethodName          = "/order.TrafficService/DeleteTraffic"
	TrafficService_GetTrafficRecords_FullMethodName      = "/order.TrafficService/GetTrafficRecords"
	TrafficService_DisableTraderTraffic_FullMethodName   = "/order.TrafficService/DisableTraderTraffic"
	TrafficService_EnableTraderTraffic_FullMethodName    = "/order.TrafficService/EnableTraderTraffic"
	TrafficService_GetTraderTrafficStatus_FullMethodName = "/order.TrafficService/GetTraderTrafficStatus"
)

// TrafficServiceClient is the client API for TrafficService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrafficServiceClient interface {
	AddTraffic(ctx context.Context, in *AddTrafficRequest, opts ...grpc.CallOption) (*AddTrafficResponse, error)
	EditTraffic(ctx context.Context, in *EditTrafficRequest, opts ...grpc.CallOption) (*EditTrafficResponse, error)
	DeleteTraffic(ctx context.Context, in *DeleteTrafficRequest, opts ...grpc.CallOption) (*DeleteTrafficResponse, error)
	GetTrafficRecords(ctx context.Context, in *GetTrafficRecordsRequest, opts ...grpc.CallOption) (*GetTrafficRecordsResponse, error)
	DisableTraderTraffic(ctx context.Context, in *DisableTraderTrafficRequest, opts ...grpc.CallOption) (*DisableTraderTrafficResponse, error)
	EnableTraderTraffic(ctx context.Context, in *EnableTraderTrafficRequest, opts ...grpc.CallOption) (*EnableTraderTrafficResponse, error)
	GetTraderTrafficStatus(ctx context.Context, in *GetTraderTrafficStatusRequest, opts ...grpc.CallOption) (*GetTraderTrafficStatusResponse, error)
}

type trafficServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTrafficServiceClient(cc grpc.ClientConnInterface) TrafficServiceClient {
	return &trafficServiceClient{cc}
}

func (c *trafficServiceClient) AddTraffic(ctx context.Context, in *AddTrafficRequest, opts ...grpc.CallOption) (*AddTrafficResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddTrafficResponse)
	err := c.cc.Invoke(ctx, TrafficService_AddTraffic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trafficServiceClient) EditTraffic(ctx context.Context, in *EditTrafficRequest, opts ...grpc.CallOption) (*EditTrafficResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditTrafficResponse)
	err := c.cc.Invoke(ctx, TrafficService_EditTraffic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trafficServiceClient) DeleteTraffic(ctx context.Context, in *DeleteTrafficRequest, opts ...grpc.CallOption) (*DeleteTrafficResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTrafficResponse)
	err := c.cc.Invoke(ctx, TrafficService_DeleteTraffic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trafficServiceClient) GetTrafficRecords(ctx context.Context, in *GetTrafficRecordsRequest, opts ...grpc.CallOption) (*GetTrafficRecordsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTrafficRecordsResponse)
	err := c.cc.Invoke(ctx, TrafficService_GetTrafficRecords_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trafficServiceClient) DisableTraderTraffic(ctx context.Context, in *DisableTraderTrafficRequest, opts ...grpc.CallOption) (*DisableTraderTrafficResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisableTraderTrafficResponse)
	err := c.cc.Invoke(ctx, TrafficService_DisableTraderTraffic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trafficServiceClient) EnableTraderTraffic(ctx context.Context, in *EnableTraderTrafficRequest, opts ...grpc.CallOption) (*EnableTraderTrafficResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableTraderTrafficResponse)
	err := c.cc.Invoke(ctx, TrafficService_EnableTraderTraffic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trafficServiceClient) GetTraderTrafficStatus(ctx context.Context, in *GetTraderTrafficStatusRequest, opts ...grpc.CallOption) (*GetTraderTrafficStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTraderTrafficStatusResponse)
	err := c.cc.Invoke(ctx, TrafficService_GetTraderTrafficStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrafficServiceServer is the server API for TrafficService service.
// All implementations must embed UnimplementedTrafficServiceServer
// for forward compatibility.
type TrafficServiceServer interface {
	AddTraffic(context.Context, *AddTrafficRequest) (*AddTrafficResponse, error)
	EditTraffic(context.Context, *EditTrafficRequest) (*EditTrafficResponse, error)
	DeleteTraffic(context.Context, *DeleteTrafficRequest) (*DeleteTrafficResponse, error)
	GetTrafficRecords(context.Context, *GetTrafficRecordsRequest) (*GetTrafficRecordsResponse, error)
	DisableTraderTraffic(context.Context, *DisableTraderTrafficRequest) (*DisableTraderTrafficResponse, error)
	EnableTraderTraffic(context.Context, *EnableTraderTrafficRequest) (*EnableTraderTrafficResponse, error)
	GetTraderTrafficStatus(context.Context, *GetTraderTrafficStatusRequest) (*GetTraderTrafficStatusResponse, error)
	mustEmbedUnimplementedTrafficServiceServer()
}

// UnimplementedTrafficServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTrafficServiceServer struct{}

func (UnimplementedTrafficServiceServer) AddTraffic(context.Context, *AddTrafficRequest) (*AddTrafficResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTraffic not implemented")
}
func (UnimplementedTrafficServiceServer) EditTraffic(context.Context, *EditTrafficRequest) (*EditTrafficResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditTraffic not implemented")
}
func (UnimplementedTrafficServiceServer) DeleteTraffic(context.Context, *DeleteTrafficRequest) (*DeleteTrafficResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTraffic not implemented")
}
func (UnimplementedTrafficServiceServer) GetTrafficRecords(context.Context, *GetTrafficRecordsRequest) (*GetTrafficRecordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrafficRecords not implemented")
}
func (UnimplementedTrafficServiceServer) DisableTraderTraffic(context.Context, *DisableTraderTrafficRequest) (*DisableTraderTrafficResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableTraderTraffic not implemented")
}
func (UnimplementedTrafficServiceServer) EnableTraderTraffic(context.Context, *EnableTraderTrafficRequest) (*EnableTraderTrafficResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableTraderTraffic not implemented")
}
func (UnimplementedTrafficServiceServer) GetTraderTrafficStatus(context.Context, *GetTraderTrafficStatusRequest) (*GetTraderTrafficStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTraderTrafficStatus not implemented")
}
func (UnimplementedTrafficServiceServer) mustEmbedUnimplementedTrafficServiceServer() {}
func (UnimplementedTrafficServiceServer) testEmbeddedByValue()                        {}

// UnsafeTrafficServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrafficServiceServer will
// result in compilation errors.
type UnsafeTrafficServiceServer interface {
	mustEmbedUnimplementedTrafficServiceServer()
}

func RegisterTrafficServiceServer(s grpc.ServiceRegistrar, srv TrafficServiceServer) {
	// If the following call pancis, it indicates UnimplementedTrafficServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TrafficService_ServiceDesc, srv)
}

func _TrafficService_AddTraffic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTrafficRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrafficServiceServer).AddTraffic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrafficService_AddTraffic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrafficServiceServer).AddTraffic(ctx, req.(*AddTrafficRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrafficService_EditTraffic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditTrafficRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrafficServiceServer).EditTraffic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrafficService_EditTraffic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrafficServiceServer).EditTraffic(ctx, req.(*EditTrafficRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrafficService_DeleteTraffic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTrafficRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrafficServiceServer).DeleteTraffic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrafficService_DeleteTraffic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrafficServiceServer).DeleteTraffic(ctx, req.(*DeleteTrafficRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrafficService_GetTrafficRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTrafficRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrafficServiceServer).GetTrafficRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrafficService_GetTrafficRecords_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrafficServiceServer).GetTrafficRecords(ctx, req.(*GetTrafficRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrafficService_DisableTraderTraffic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableTraderTrafficRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrafficServiceServer).DisableTraderTraffic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrafficService_DisableTraderTraffic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrafficServiceServer).DisableTraderTraffic(ctx, req.(*DisableTraderTrafficRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrafficService_EnableTraderTraffic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableTraderTrafficRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrafficServiceServer).EnableTraderTraffic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrafficService_EnableTraderTraffic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrafficServiceServer).EnableTraderTraffic(ctx, req.(*EnableTraderTrafficRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrafficService_GetTraderTrafficStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTraderTrafficStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrafficServiceServer).GetTraderTrafficStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrafficService_GetTraderTrafficStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrafficServiceServer).GetTraderTrafficStatus(ctx, req.(*GetTraderTrafficStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TrafficService_ServiceDesc is the grpc.ServiceDesc for TrafficService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TrafficService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "order.TrafficService",
	HandlerType: (*TrafficServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddTraffic",
			Handler:    _TrafficService_AddTraffic_Handler,
		},
		{
			MethodName: "EditTraffic",
			Handler:    _TrafficService_EditTraffic_Handler,
		},
		{
			MethodName: "DeleteTraffic",
			Handler:    _TrafficService_DeleteTraffic_Handler,
		},
		{
			MethodName: "GetTrafficRecords",
			Handler:    _TrafficService_GetTrafficRecords_Handler,
		},
		{
			MethodName: "DisableTraderTraffic",
			Handler:    _TrafficService_DisableTraderTraffic_Handler,
		},
		{
			MethodName: "EnableTraderTraffic",
			Handler:    _TrafficService_EnableTraderTraffic_Handler,
		},
		{
			MethodName: "GetTraderTrafficStatus",
			Handler:    _TrafficService_GetTraderTrafficStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "order.proto",
}
